<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PDF/CDF Distribution Visualizer</title>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #f5f6f8; color: #333; padding: 1.25rem; }
  h1 { margin-bottom: .2rem; font-size: 1.4rem; letter-spacing: -.02em; }
  .subtitle { color: #999; font-size: .75rem; margin-bottom: .5rem; }

  .page-layout { display: grid; grid-template-columns: 310px 1fr; gap: 1.25rem; max-width: 1200px; margin: 0 auto; }
  .sidebar { display: flex; flex-direction: column; gap: .5rem; position: sticky; top: 1rem; align-self: start; z-index: 10; }

  .card { background: #fff; padding: .7rem .85rem; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.08); }
  .card-title { font-weight: 600; font-size: .75rem; text-transform: uppercase; letter-spacing: .04em; color: #888; margin-bottom: .4rem; }

  /* Distribution selector */
  .dist-selector { display: flex; flex-direction: column; gap: .4rem; }
  .dist-selector select { font-size: .88rem; padding: .4rem .5rem; border-radius: 6px; border: 1px solid #ddd; width: 100%; background: #fff; cursor: pointer; }
  .dist-selector select:focus { outline: none; border-color: #6c5ce7; box-shadow: 0 0 0 2px rgba(108,92,231,.15); }

  /* Distribution description */
  .dist-desc { font-size: .75rem; color: #777; font-style: italic; margin-top: .3rem; line-height: 1.35; }

  /* Parameters */
  .param-row { display: flex; align-items: center; gap: .5rem; margin-bottom: .3rem; }
  .param-label { font-size: .82rem; font-weight: 600; min-width: 1.2rem; cursor: help; border-bottom: 1px dotted #bbb; }
  .param-label:focus { outline: 2px solid rgba(108,92,231,.3); outline-offset: 2px; border-radius: 2px; }
  .param-desc { font-size: .7rem; color: #aaa; min-width: 3.5rem; }
  .param-row input[type=range] { flex: 1; height: 4px; cursor: pointer; }
  .param-row .val { width: 3.2rem; text-align: right; font-variant-numeric: tabular-nums; font-size: .8rem; padding: .15rem .25rem; border: 1px solid #ddd; border-radius: 4px; }
  .param-row .val:focus { outline: none; border-color: #6c5ce7; box-shadow: 0 0 0 2px rgba(108,92,231,.15); }
  .param-hint { font-size: .72rem; color: #7a7a7a; margin-top: .35rem; line-height: 1.35; min-height: 1.2em; }

  /* Formulas */
  #formula { border-left: 3px solid #eee; }
  #formula .formula-row { margin-bottom: .3rem; display: flex; align-items: baseline; gap: .35rem; font-size: .85rem; overflow-x: auto; scrollbar-width: thin; }
  #formula .formula-row::-webkit-scrollbar { height: 3px; }
  #formula .formula-row::-webkit-scrollbar-thumb { background: #ddd; border-radius: 3px; }
  #formula .formula-row b { flex-shrink: 0; font-size: .72rem; padding: .1rem .3rem; border-radius: 3px; }
  #formula .formula-row b.pdf-label { color: #e74c3c; background: #fdf0ef; }
  #formula .formula-row b.cdf-label { color: #3498db; background: #eef6fd; }

  /* Stat legend below PDF */
  .stat-bar { display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap; font-size: .7rem; color: #666; padding: .25rem 0; }
  .stat-bar span { display: flex; align-items: center; gap: .25rem; font-variant-numeric: tabular-nums; }
  .stat-swatch { width: 14px; height: 0; border-top: 2px dashed; display: inline-block; }
  .stat-swatch.mean { border-color: #2ecc71; }
  .stat-swatch.median { border-color: #9b59b6; }
  .stat-swatch.mode { border-color: #f39c12; border-top-style: dotted; }
  .stat-swatch.sigma { width: 14px; height: 8px; border: none; background: rgba(46,204,113,0.15); border-left: 1px solid rgba(46,204,113,0.4); border-right: 1px solid rgba(46,204,113,0.4); }

  /* Prob calculator */
  #prob-calc { background: #faf9ff; border: 1px solid #ece8ff; }
  .prob-row { display: flex; align-items: center; gap: .3rem; font-size: .82rem; margin-bottom: .35rem; }
  .prob-row input[type=number] { width: 4.2rem; padding: .2rem .25rem; border: 1px solid #ddd; border-radius: 4px; font-size: .8rem; text-align: center; }
  .prob-row input[type=number]:focus { outline: none; border-color: #6c5ce7; box-shadow: 0 0 0 2px rgba(108,92,231,.15); }
  .prob-row input[type=number].invalid { border-color: #e74c3c; box-shadow: 0 0 0 2px rgba(231,76,60,.15); }
  .prob-row input[type=number].inf-active { opacity: .3; pointer-events: none; }
  .inf-btn { background: none; border: 1.5px solid #ccc; border-radius: 4px; padding: .1rem .35rem; font-size: .75rem; cursor: pointer; color: #999; transition: all .15s; }
  .inf-btn:hover { border-color: #6c5ce7; color: #6c5ce7; }
  .inf-btn.active { background: #6c5ce7; color: #fff; border-color: #6c5ce7; }
  .prob-result { font-size: 1rem; font-weight: 700; color: #6c5ce7; text-align: center; padding: .2rem 0; }

  /* Plots */
  .plots { display: flex; flex-direction: column; gap: 1rem; position: relative; }
  .plot { background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.08); position: relative; }

  /* Explainer */
  .explainer-card .card-title a { color: #888; text-decoration: none; border-bottom: 1px dotted #ccc; }
  .explainer-card .card-title a:hover { color: #6c5ce7; border-color: #6c5ce7; }
  #explainer p { font-size: .78rem; color: #555; margin-bottom: .3rem; line-height: 1.4; margin-top: .3rem; }
  #explainer p:last-child { margin-bottom: 0; }

  /* Keyboard hint */
  .kbd-hint { text-align: center; font-size: .68rem; color: #bbb; margin-top: .25rem; }
  kbd { background: #eee; border: 1px solid #ddd; border-radius: 3px; padding: 0 .3rem; font-family: inherit; font-size: .65rem; }
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
  .prob-msg { font-size: .72rem; color: #b24a4a; text-align: center; min-height: 1em; }
  @media (max-width: 800px) {
    .page-layout { grid-template-columns: 1fr; }
    .sidebar { position: static; }
  }
</style>
</head>
<body>
<div class="page-layout">
  <div class="sidebar">
    <h1>Distribution Visualizer</h1>
    <p class="subtitle">PDF &amp; CDF explorer</p>
    <div class="card dist-selector">
      <div class="card-title">Distribution</div>
      <label class="sr-only" for="dist">Distribution</label>
      <select id="dist"></select>
      <div id="dist-desc" class="dist-desc"></div>
    </div>
    <div class="card" id="params-card" style="display:none">
      <div class="card-title">Parameters</div>
      <div id="params"></div>
      <div class="param-hint" id="param-hint" aria-live="polite"></div>
    </div>
    <div class="card" id="formula"></div>
    <div class="card" id="prob-calc">
      <div class="card-title">Probability</div>
      <div class="prob-row">
        <span>P(</span>
        <button class="inf-btn" id="inf-a" title="Set to −∞" aria-pressed="false">−∞</button>
        <label class="sr-only" for="prob-a">Lower bound</label>
        <input type="number" id="prob-a" step="0.1" value="-1">
        <span>&lt; X &lt;</span>
        <label class="sr-only" for="prob-b">Upper bound</label>
        <input type="number" id="prob-b" step="0.1" value="1">
        <button class="inf-btn" id="inf-b" title="Set to +∞" aria-pressed="false">+∞</button>
        <span>)</span>
      </div>
      <div class="prob-result" id="prob-result" aria-live="polite">&mdash;</div>
      <div class="prob-msg" id="prob-msg" aria-live="polite"></div>
    </div>
    <div class="card explainer-card">
      <div class="card-title"><a href="#" id="explainer-btn">What am I looking at?</a></div>
      <div id="explainer" style="display:none">
        <p><b style="color:#e74c3c">PDF</b> — Height shows relative likelihood. The shaded area between two points = probability.</p>
        <p><b style="color:#3498db">CDF</b> — Shows P(X &le; x), the cumulative probability. Non-decreasing from 0 to 1.</p>
      </div>
    </div>
    <div class="kbd-hint"><kbd>&#x2191;</kbd><kbd>&#x2193;</kbd> to switch distributions</div>
  </div>
  <div class="plots">
    <div id="pdf-plot" class="plot"></div>
    <div class="stat-bar" id="stat-bar"></div>
    <div id="cdf-plot" class="plot"></div>
  </div>
</div>

<script>
// --- Special functions ---
function erf(x) {
  const t = 1/(1+0.3275911*Math.abs(x));
  const poly = t*(0.254829592+t*(-0.284496736+t*(1.421413741+t*(-1.453152027+t*1.061405429))));
  const v = 1 - poly*Math.exp(-x*x);
  return x >= 0 ? v : -v;
}

function lnGamma(z) {
  if (z < 0.5) return Math.log(Math.PI/Math.sin(Math.PI*z)) - lnGamma(1-z);
  z -= 1;
  const g = 7, c = [0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313,
    -176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7];
  let s = c[0];
  for (let i = 1; i < g+2; i++) s += c[i]/(z+i);
  const t = z + g + 0.5;
  return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(s);
}

function gamma(z) { return Math.exp(lnGamma(z)); }
function lnBeta(a, b) { return lnGamma(a) + lnGamma(b) - lnGamma(a+b); }

function regGammaP(a, x) {
  if (x === Infinity) return 1;
  if (x <= 0) return 0;
  const logGamA = lnGamma(a);
  if (x < a + 1) {
    let sum = 1/a, term = 1/a;
    for (let n = 1; n < 200; n++) {
      term *= x/(a+n);
      sum += term;
      if (Math.abs(term) < 1e-14*Math.abs(sum)) break;
    }
    return Math.min(1, Math.max(0, sum * Math.exp(-x + a*Math.log(x) - logGamA)));
  }
  // Continued fraction for Q(a, x), then P = 1 - Q
  let b = x + 1 - a;
  let c = 1e30;
  let d = 1 / b;
  let h = d;
  for (let i = 1; i <= 200; i++) {
    const an = -i * (i - a);
    b += 2;
    d = an * d + b;
    if (Math.abs(d) < 1e-30) d = 1e-30;
    c = b + an / c;
    if (Math.abs(c) < 1e-30) c = 1e-30;
    d = 1 / d;
    const del = d * c;
    h *= del;
    if (Math.abs(del - 1) < 1e-14) break;
  }
  const q = Math.exp(-x + a*Math.log(x) - logGamA) * h;
  const p = 1 - q;
  return Math.min(1, Math.max(0, p));
}

function regBetaI(x, a, b) {
  if (x <= 0) return 0;
  if (x >= 1) return 1;
  if (x > (a+1)/(a+b+2)) return 1 - regBetaI(1-x, b, a);
  const front = Math.exp(a*Math.log(x) + b*Math.log(1-x) - lnBeta(a,b)) / a;
  let f = 1, c = 1, d = 0;
  for (let m = 0; m <= 200; m++) {
    let num;
    if (m === 0) { num = 1; }
    else if (m % 2 === 0) { const k=m/2; num = k*(b-k)*x/((a+2*k-1)*(a+2*k)); }
    else { const k=(m-1)/2; num = -(a+k)*(a+b+k)*x/((a+2*k)*(a+2*k+1)); }
    d = 1+num*d; if(Math.abs(d)<1e-30) d=1e-30; d=1/d;
    c = 1+num/c; if(Math.abs(c)<1e-30) c=1e-30;
    f *= c*d;
    if(Math.abs(c*d-1)<1e-14 && m>0) break;
  }
  return front * f;
}

// --- Distribution definitions ---
const DISTS = {
  normal: {
    label: 'Normal',
    description: 'The bell curve — models sums of many small random effects.',
    params: [
      { name: 'μ', desc: 'mean', hint: 'Location (mean); appears as (x−μ) in the PDF. Domain: μ ∈ ℝ.', min: -5, max: 5, step: 0.1, init: 0 },
      { name: 'σ', desc: 'std dev', hint: 'Scale (std dev); appears in denominator and in (x−μ)/σ. Domain: σ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: (p) => [p['μ']-20, p['μ']+20],
    pdf: (x,p) => Math.exp(-0.5*((x-p['μ'])/p['σ'])**2)/(p['σ']*Math.sqrt(2*Math.PI)),
    cdf: (x,p) => 0.5*(1+erf((x-p['μ'])/(p['σ']*Math.SQRT2))),
    mean: (p) => p['μ'],
    variance: (p) => p['σ']**2,
    mode: (p) => p['μ'],
    formula: [
      ['PDF','f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\, e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}'],
      ['CDF','F(x) = \\frac{1}{2}\\left[1 + \\operatorname{erf}\\!\\left(\\frac{x-\\mu}{\\sigma\\sqrt{2}}\\right)\\right]'],
    ],
  },
  exponential: {
    label: 'Exponential',
    description: 'Models waiting times between events occurring at a constant rate.',
    params: [{ name: 'λ', desc: 'rate', hint: 'Rate; appears as e^{−λx} and λ in front. Domain: λ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 }],
    range: () => [0, 20],
    pdf: (x,p) => x<0?0:p['λ']*Math.exp(-p['λ']*x),
    cdf: (x,p) => x<0?0:1-Math.exp(-p['λ']*x),
    mean: (p) => 1/p['λ'],
    variance: (p) => 1/(p['λ']**2),
    mode: () => 0,
    formula: [
      ['PDF','f(x) = \\lambda\\, e^{-\\lambda x}, \\quad x \\ge 0'],
      ['CDF','F(x) = 1 - e^{-\\lambda x}'],
    ],
  },
  uniform: {
    label: 'Uniform',
    description: 'Equal probability everywhere between a and b.',
    params: [
      { name: 'a', desc: 'lower', hint: 'Lower endpoint of support [a,b]; appears in (x−a)/(b−a). Domain: a < b.', min: -5, max: 4, step: 0.1, init: 0 },
      { name: 'b', desc: 'upper', hint: 'Upper endpoint of support [a,b]; appears in (b−a). Domain: b > a.', min: -4, max: 5, step: 0.1, init: 1 },
    ],
    range: () => [-6, 6],
    pdf: (x,p) => (x>=p['a']&&x<=p['b'])?1/(p['b']-p['a']):0,
    cdf: (x,p) => x<p['a']?0:x>p['b']?1:(x-p['a'])/(p['b']-p['a']),
    mean: (p) => (p['a']+p['b'])/2,
    variance: (p) => (p['b']-p['a'])**2/12,
    mode: () => null,
    formula: [
      ['PDF','f(x) = \\frac{1}{b - a}, \\quad x \\in [a,\\, b]'],
      ['CDF','F(x) = \\frac{x - a}{b - a}'],
    ],
  },
  beta: {
    label: 'Beta',
    description: 'Models probabilities and proportions on [0, 1]. Common Bayesian prior.',
    params: [
      { name: 'α', desc: 'shape', hint: 'Shape exponent on x^{α−1}. Domain: α > 0.', min: 0.1, max: 10, step: 0.1, init: 2 },
      { name: 'β', desc: 'shape', hint: 'Shape exponent on (1−x)^{β−1}. Domain: β > 0.', min: 0.1, max: 10, step: 0.1, init: 5 },
    ],
    range: () => [0, 1],
    pdf: (x,p) => { if(x<=0||x>=1) return 0; return Math.exp((p['α']-1)*Math.log(x)+(p['β']-1)*Math.log(1-x)-lnBeta(p['α'],p['β'])); },
    cdf: (x,p) => x<=0?0:x>=1?1:regBetaI(x,p['α'],p['β']),
    mean: (p) => p['α']/(p['α']+p['β']),
    variance: (p) => { const a=p['α'],b=p['β']; return a*b/((a+b)**2*(a+b+1)); },
    mode: (p) => { const a=p['α'],b=p['β']; return (a>1&&b>1)?(a-1)/(a+b-2):null; },
    formula: [
      ['PDF','f(x) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha,\\beta)}, \\quad x \\in (0,1)'],
      ['CDF','F(x) = I_x(\\alpha,\\beta)'],
    ],
  },
  gamma: {
    label: 'Gamma',
    description: 'Models total waiting time for k events. Conjugate prior for Poisson/Exponential rates.',
    params: [
      { name: 'k', desc: 'shape', hint: 'Shape; exponent on x^{k−1}. Domain: k > 0.', min: 0.1, max: 10, step: 0.1, init: 2 },
      { name: 'θ', desc: 'scale', hint: 'Scale; x/θ in exponent and θ^k in denominator. Domain: θ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: () => [0, 30],
    pdf: (x,p) => { if(x<=0) return 0; return Math.exp((p['k']-1)*Math.log(x)-x/p['θ']-p['k']*Math.log(p['θ'])-lnGamma(p['k'])); },
    cdf: (x,p) => x<=0?0:regGammaP(p['k'],x/p['θ']),
    mean: (p) => p['k']*p['θ'],
    variance: (p) => p['k']*p['θ']**2,
    mode: (p) => p['k']>=1?(p['k']-1)*p['θ']:0,
    formula: [
      ['PDF','f(x) = \\frac{x^{k-1}\\,e^{-x/\\theta}}{\\theta^k\\,\\Gamma(k)}, \\quad x > 0'],
      ['CDF','F(x) = \\frac{\\gamma(k,\\,x/\\theta)}{\\Gamma(k)}'],
    ],
  },
  chisq: {
    label: 'Chi-squared',
    description: 'Sum of k squared standard normals. Used in hypothesis testing and confidence intervals.',
    params: [{ name: 'k', desc: 'deg free', hint: 'Degrees of freedom (df); equals 2·shape in Gamma form. Domain: k > 0.', min: 1, max: 20, step: 1, init: 3 }],
    range: () => [0, 35],
    pdf: (x,p) => { if(x<=0) return 0; const h=p['k']/2; return Math.exp((h-1)*Math.log(x)-x/2-h*Math.LN2-lnGamma(h)); },
    cdf: (x,p) => x<=0?0:regGammaP(p['k']/2,x/2),
    mean: (p) => p['k'],
    variance: (p) => 2*p['k'],
    mode: (p) => Math.max(0,p['k']-2),
    formula: [
      ['PDF','f(x) = \\frac{x^{k/2-1}\\,e^{-x/2}}{2^{k/2}\\,\\Gamma(k/2)}, \\quad x > 0'],
      ['CDF','F(x) = \\frac{\\gamma(k/2,\\,x/2)}{\\Gamma(k/2)}'],
    ],
  },
  t: {
    label: "Student's t",
    description: 'Like Normal but with heavier tails. Approaches Normal as degrees of freedom grow.',
    params: [{ name: 'ν', desc: 'deg free', hint: 'Degrees of freedom (df); controls tail weight. Domain: ν > 0.', min: 1, max: 50, step: 1, init: 5 }],
    range: () => [-12, 12],
    pdf: (x,p) => { const v=p['ν']; return Math.exp(lnGamma((v+1)/2)-lnGamma(v/2)-0.5*Math.log(v*Math.PI)-(v+1)/2*Math.log(1+x*x/v)); },
    cdf: (x,p) => { const v=p['ν'], t=v/(v+x*x); const ib=regBetaI(t,v/2,0.5); return x>=0?1-0.5*ib:0.5*ib; },
    mean: (p) => p['ν']>1?0:null,
    variance: (p) => p['ν']>2?p['ν']/(p['ν']-2):p['ν']>1?Infinity:null,
    mode: () => 0,
    formula: [
      ['PDF','f(x) = \\frac{\\Gamma\\!\\left(\\frac{\\nu+1}{2}\\right)}{\\sqrt{\\nu\\pi}\\;\\Gamma\\!\\left(\\frac{\\nu}{2}\\right)}\\left(1+\\frac{x^2}{\\nu}\\right)^{\\!-\\frac{\\nu+1}{2}}'],
      ['CDF','F(x) = \\tfrac{1}{2} + x\\,\\Gamma\\!\\left(\\tfrac{\\nu+1}{2}\\right) \\cdot \\dfrac{_2F_1\\!\\left(\\tfrac{1}{2},\\tfrac{\\nu+1}{2};\\tfrac{3}{2};-\\tfrac{x^2}{\\nu}\\right)}{\\sqrt{\\nu\\pi}\\;\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)}'],
    ],
  },
  lognormal: {
    label: 'Log-normal',
    description: 'Models positive quantities whose log is Normal. Common for prices, sizes, lifetimes.',
    params: [
      { name: 'μ', desc: 'log mean', hint: 'Mean of ln(X) when ln(X)~N(μ,σ²). Domain: μ ∈ ℝ.', min: -3, max: 3, step: 0.1, init: 0 },
      { name: 'σ', desc: 'log std', hint: 'Std dev of ln(X) when ln(X)~N(μ,σ²). Domain: σ > 0.', min: 0.1, max: 2, step: 0.1, init: 0.5 },
    ],
    range: () => [0, 20],
    pdf: (x,p) => { if(x<=0) return 0; return Math.exp(-0.5*((Math.log(x)-p['μ'])/p['σ'])**2)/(x*p['σ']*Math.sqrt(2*Math.PI)); },
    cdf: (x,p) => x<=0?0:0.5*(1+erf((Math.log(x)-p['μ'])/(p['σ']*Math.SQRT2))),
    mean: (p) => Math.exp(p['μ']+p['σ']**2/2),
    variance: (p) => (Math.exp(p['σ']**2)-1)*Math.exp(2*p['μ']+p['σ']**2),
    mode: (p) => Math.exp(p['μ']-p['σ']**2),
    formula: [
      ['PDF','f(x) = \\frac{1}{x\\sigma\\sqrt{2\\pi}}\\,e^{-\\frac{(\\ln x - \\mu)^2}{2\\sigma^2}}, \\quad x > 0'],
      ['CDF','F(x) = \\frac{1}{2}\\left[1+\\operatorname{erf}\\!\\left(\\frac{\\ln x - \\mu}{\\sigma\\sqrt{2}}\\right)\\right]'],
    ],
  },
  weibull: {
    label: 'Weibull',
    description: 'Flexible lifetime model. k<1: decreasing failure rate, k=1: Exponential, k>1: increasing.',
    params: [
      { name: 'k', desc: 'shape', hint: 'Shape; exponent in (x/λ)^{k}. Domain: k > 0.', min: 0.1, max: 5, step: 0.1, init: 1.5 },
      { name: 'λ', desc: 'scale', hint: 'Scale; divides x inside (x/λ)^{k}. Domain: λ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: () => [0, 12],
    pdf: (x,p) => { if(x<=0) return 0; const k=p['k'],l=p['λ']; return (k/l)*Math.pow(x/l,k-1)*Math.exp(-Math.pow(x/l,k)); },
    cdf: (x,p) => x<=0?0:1-Math.exp(-Math.pow(x/p['λ'],p['k'])),
    mean: (p) => p['λ']*gamma(1+1/p['k']),
    variance: (p) => { const m1=gamma(1+1/p['k']),m2=gamma(1+2/p['k']); return p['λ']*p['λ']*(m2-m1*m1); },
    mode: (p) => p['k']>1?p['λ']*Math.pow((p['k']-1)/p['k'],1/p['k']):0,
    formula: [
      ['PDF','f(x) = \\frac{k}{\\lambda}\\left(\\frac{x}{\\lambda}\\right)^{k-1} e^{-(x/\\lambda)^k}, \\quad x > 0'],
      ['CDF','F(x) = 1 - e^{-(x/\\lambda)^k}'],
    ],
  },
  f: {
    label: 'F',
    description: 'Ratio of scaled chi-squared variables. Used in ANOVA and variance tests.',
    params: [
      { name: 'ν₁', desc: 'df1', hint: 'Numerator df of the F ratio; appears as ν₁/2 in Beta form. Domain: ν₁ > 0.', min: 1, max: 50, step: 1, init: 5 },
      { name: 'ν₂', desc: 'df2', hint: 'Denominator df of the F ratio; appears as ν₂/2 in Beta form. Domain: ν₂ > 0.', min: 1, max: 100, step: 1, init: 10 },
    ],
    range: () => [0, 6],
    pdf: (x,p) => {
      if (x <= 0) return 0;
      const d1 = p['ν₁'], d2 = p['ν₂'];
      const num = Math.pow(d1/d2, d1/2) * Math.pow(x, d1/2 - 1);
      const den = lnBeta(d1/2, d2/2) + ((d1 + d2)/2) * Math.log(1 + (d1/d2) * x);
      return Math.exp(Math.log(num) - den);
    },
    cdf: (x,p) => {
      if (x <= 0) return 0;
      const d1 = p['ν₁'], d2 = p['ν₂'];
      const z = (d1 * x) / (d1 * x + d2);
      return regBetaI(z, d1/2, d2/2);
    },
    mean: (p) => p['ν₂'] > 2 ? p['ν₂'] / (p['ν₂'] - 2) : null,
    variance: (p) => {
      const d1 = p['ν₁'], d2 = p['ν₂'];
      if (d2 <= 4) return null;
      return (2 * d2 * d2 * (d1 + d2 - 2)) / (d1 * (d2 - 2) * (d2 - 2) * (d2 - 4));
    },
    mode: (p) => {
      const d1 = p['ν₁'], d2 = p['ν₂'];
      if (d1 <= 2) return null;
      return ((d1 - 2) / d1) * (d2 / (d2 + 2));
    },
    formula: [
      ['PDF','f(x) = \\frac{(\\nu_1/\\nu_2)^{\\nu_1/2}\\,x^{\\nu_1/2-1}}{B(\\nu_1/2,\\nu_2/2)\\left(1+(\\nu_1/\\nu_2)x\\right)^{(\\nu_1+\\nu_2)/2}}'],
      ['CDF','F(x) = I_{\\frac{\\nu_1 x}{\\nu_1 x + \\nu_2}}\\!\\left(\\frac{\\nu_1}{2},\\frac{\\nu_2}{2}\\right)'],
    ],
  },
  laplace: {
    label: 'Laplace',
    description: 'Sharp peak with heavier tails than Normal. Difference of two exponentials.',
    params: [
      { name: 'μ', desc: 'location', hint: 'Location; peak at x=μ. Domain: μ ∈ ℝ.', min: -5, max: 5, step: 0.1, init: 0 },
      { name: 'b', desc: 'scale', hint: 'Scale; appears as |x−μ|/b. Domain: b > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: (p) => [p['μ']-10, p['μ']+10],
    pdf: (x,p) => Math.exp(-Math.abs(x - p['μ'])/p['b'])/(2*p['b']),
    cdf: (x,p) => x < p['μ'] ? 0.5*Math.exp((x - p['μ'])/p['b']) : 1 - 0.5*Math.exp(-(x - p['μ'])/p['b']),
    mean: (p) => p['μ'],
    variance: (p) => 2 * p['b'] * p['b'],
    mode: (p) => p['μ'],
    formula: [
      ['PDF','f(x)=\\frac{1}{2b}\\,e^{-|x-\\mu|/b}'],
      ['CDF','F(x)=\\begin{cases}\\tfrac{1}{2}e^{(x-\\mu)/b}, & x<\\mu \\\\ 1-\\tfrac{1}{2}e^{-(x-\\mu)/b}, & x\\ge \\mu\\end{cases}'],
    ],
  },
  logistic: {
    label: 'Logistic',
    description: 'Similar to Normal with heavier tails. CDF is the logistic function.',
    params: [
      { name: 'μ', desc: 'location', hint: 'Location; center of the logistic CDF. Domain: μ ∈ ℝ.', min: -5, max: 5, step: 0.1, init: 0 },
      { name: 's', desc: 'scale', hint: 'Scale; appears in (x−μ)/s in CDF. Domain: s > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: (p) => [p['μ']-10, p['μ']+10],
    pdf: (x,p) => {
      const z = (x - p['μ'])/p['s'];
      const ez = Math.exp(-z);
      return ez / (p['s'] * Math.pow(1 + ez, 2));
    },
    cdf: (x,p) => 1 / (1 + Math.exp(-(x - p['μ'])/p['s'])),
    mean: (p) => p['μ'],
    variance: (p) => (p['s'] * p['s'] * Math.PI * Math.PI) / 3,
    mode: (p) => p['μ'],
    formula: [
      ['PDF','f(x)=\\frac{e^{-(x-\\mu)/s}}{s\\left(1+e^{-(x-\\mu)/s}\\right)^2}'],
      ['CDF','F(x)=\\frac{1}{1+e^{-(x-\\mu)/s}}'],
    ],
  },
  cauchy: {
    label: 'Cauchy',
    description: 'Very heavy tails; mean and variance are undefined.',
    params: [
      { name: 'x₀', desc: 'location', hint: 'Location; center of symmetry. Domain: x₀ ∈ ℝ.', min: -5, max: 5, step: 0.1, init: 0 },
      { name: 'γ', desc: 'scale', hint: 'Scale; half‑width at half‑maximum. Domain: γ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
    ],
    range: (p) => [p['x₀']-12, p['x₀']+12],
    pdf: (x,p) => 1 / (Math.PI * p['γ'] * (1 + Math.pow((x - p['x₀'])/p['γ'], 2))),
    cdf: (x,p) => (1/Math.PI) * Math.atan((x - p['x₀'])/p['γ']) + 0.5,
    mean: () => null,
    variance: () => null,
    mode: (p) => p['x₀'],
    formula: [
      ['PDF','f(x)=\\frac{1}{\\pi\\gamma\\left[1+\\left(\\frac{x-x_0}{\\gamma}\\right)^2\\right]}'],
      ['CDF','F(x)=\\frac{1}{\\pi}\\arctan\\!\\left(\\frac{x-x_0}{\\gamma}\\right)+\\frac{1}{2}'],
    ],
  },
  pareto: {
    label: 'Pareto',
    description: 'Heavy-tailed model for wealth, sizes, and extreme events.',
    params: [
      { name: 'xₘ', desc: 'scale', hint: 'Minimum support value; x ≥ xₘ. Domain: xₘ > 0.', min: 0.1, max: 5, step: 0.1, init: 1 },
      { name: 'α', desc: 'shape', hint: 'Tail index; exponent on x^{−(α+1)}. Domain: α > 0.', min: 0.2, max: 10, step: 0.1, init: 2 },
    ],
    range: (p) => [p['xₘ'], p['xₘ'] * 8],
    pdf: (x,p) => {
      if (x < p['xₘ']) return 0;
      return (p['α'] * Math.pow(p['xₘ'], p['α'])) / Math.pow(x, p['α'] + 1);
    },
    cdf: (x,p) => x < p['xₘ'] ? 0 : 1 - Math.pow(p['xₘ']/x, p['α']),
    mean: (p) => p['α'] > 1 ? (p['α'] * p['xₘ']) / (p['α'] - 1) : Infinity,
    variance: (p) => p['α'] > 2 ? (p['α'] * p['xₘ'] * p['xₘ']) / ((p['α'] - 1) * (p['α'] - 1) * (p['α'] - 2)) : Infinity,
    mode: (p) => p['xₘ'],
    formula: [
      ['PDF','f(x)=\\frac{\\alpha x_m^{\\alpha}}{x^{\\alpha+1}}, \\quad x\\ge x_m'],
      ['CDF','F(x)=1-\\left(\\frac{x_m}{x}\\right)^{\\alpha}'],
    ],
  },
};

// --- UI ---
const distSelect = document.getElementById('dist');
const paramsDiv = document.getElementById('params');
const paramsCard = document.getElementById('params-card');
const paramHint = document.getElementById('param-hint');
const formulaDiv = document.getElementById('formula');
const probResult = document.getElementById('prob-result');
const probMsg = document.getElementById('prob-msg');
const probA = document.getElementById('prob-a');
const probB = document.getElementById('prob-b');
const infABtn = document.getElementById('inf-a');
const infBBtn = document.getElementById('inf-b');

for (const [key, d] of Object.entries(DISTS)) {
  const opt = document.createElement('option');
  opt.value = key; opt.textContent = d.label;
  distSelect.appendChild(opt);
}

let sliders = {};
let infAActive = false, infBActive = false;
const PLOT_QUANTILES = { low: 0.001, high: 0.999 };
let lastEditedBound = null;
let lastValidBounds = { a: null, b: null };

function setProbValidity(isValid) {
  const invalid = !isValid;
  probA.classList.toggle('invalid', invalid);
  probB.classList.toggle('invalid', invalid);
  probA.setAttribute('aria-invalid', invalid ? 'true' : 'false');
  probB.setAttribute('aria-invalid', invalid ? 'true' : 'false');
}

function getProbBounds() {
  const a = infAActive ? -Infinity : parseFloat(probA.value);
  const b = infBActive ? Infinity : parseFloat(probB.value);
  return { a, b };
}

function restoreLastValid(edited) {
  if (edited === 'a' && lastValidBounds.a !== null) {
    probA.value = lastValidBounds.a;
    return;
  }
  if (edited === 'b' && lastValidBounds.b !== null) {
    probB.value = lastValidBounds.b;
    return;
  }
  if (lastValidBounds.a !== null) probA.value = lastValidBounds.a;
  if (lastValidBounds.b !== null) probB.value = lastValidBounds.b;
}

function ensureValidBounds(edited) {
  const { a, b } = getProbBounds();
  if (!isFinite(a) && a !== -Infinity) {
    probMsg.textContent = 'Bounds must satisfy a < b';
    setProbValidity(false);
    probResult.textContent = '—';
    restoreLastValid(edited);
    return false;
  }
  if (!isFinite(b) && b !== Infinity) {
    probMsg.textContent = 'Bounds must satisfy a < b';
    setProbValidity(false);
    probResult.textContent = '—';
    restoreLastValid(edited);
    return false;
  }
  if (isNaN(a) || isNaN(b) || a >= b) {
    probMsg.textContent = 'Bounds must satisfy a < b';
    setProbValidity(false);
    probResult.textContent = '—';
    restoreLastValid(edited);
    return false;
  }
  lastValidBounds = { a: parseFloat(probA.value), b: parseFloat(probB.value) };
  setProbValidity(true);
  probMsg.textContent = '';
  return true;
}

// Keyboard nav for distribution switching
document.addEventListener('keydown', (e) => {
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
  const keys = Object.keys(DISTS);
  const idx = keys.indexOf(distSelect.value);
  if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
    e.preventDefault();
    distSelect.value = keys[(idx + 1) % keys.length];
    buildParams();
  } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
    e.preventDefault();
    distSelect.value = keys[(idx - 1 + keys.length) % keys.length];
    buildParams();
  }
});

infABtn.addEventListener('click', () => {
  infAActive = !infAActive;
  infABtn.classList.toggle('active', infAActive);
  probA.classList.toggle('inf-active', infAActive);
  infABtn.setAttribute('aria-pressed', infAActive ? 'true' : 'false');
  update();
});
infBBtn.addEventListener('click', () => {
  infBActive = !infBActive;
  infBBtn.classList.toggle('active', infBActive);
  probB.classList.toggle('inf-active', infBActive);
  infBBtn.setAttribute('aria-pressed', infBActive ? 'true' : 'false');
  update();
});

function buildParams() {
  paramsDiv.innerHTML = '';
  sliders = {};
  const d = DISTS[distSelect.value];
  paramHint.textContent = 'Hover or focus a parameter to see what it controls.';

  // Distribution description
  document.getElementById('dist-desc').textContent = d.description || '';

  // Show/hide params card
  paramsCard.style.display = d.params.length > 0 ? 'block' : 'none';

  // Formulas
  let html = '<div class="card-title">Formulas</div>';
  for (const [label, tex] of d.formula) {
    const cls = label.includes('PDF') || label.includes('PMF') ? 'pdf-label' : 'cdf-label';
    html += '<div class="formula-row"><b class="'+cls+'">' + label + '</b> <span class="katex-render">' + tex + '</span></div>';
  }
  formulaDiv.innerHTML = html;
  formulaDiv.querySelectorAll('.katex-render').forEach(el => {
    katex.render(el.textContent, el, { displayMode: false, throwOnError: false });
  });

  const initP = {};
  for (const pp of d.params) initP[pp.name] = pp.init;
  const { baseLo: rlo, baseHi: rhi } = computePlotRange(d, initP);
  const span = rhi - rlo;
  const margin = span > 0 ? span * 0.15 : 1;
  probA.value = +(rlo + margin).toFixed(2);
  probB.value = +(rhi - margin).toFixed(2);
  infAActive = false;
  infBActive = false;
  infABtn.classList.remove('active');
  infBBtn.classList.remove('active');
  probA.classList.remove('inf-active');
  probB.classList.remove('inf-active');
  setProbValidity(true);
  lastValidBounds = { a: parseFloat(probA.value), b: parseFloat(probB.value) };
  infABtn.setAttribute('aria-pressed', 'false');
  infBBtn.setAttribute('aria-pressed', 'false');

  // Sliders
  for (const p of d.params) {
    const row = document.createElement('div');
    row.className = 'param-row';

    const lbl = document.createElement('span');
    lbl.className = 'param-label';
    lbl.textContent = p.name;
    lbl.tabIndex = 0;

    const desc = document.createElement('span');
    desc.className = 'param-desc';
    desc.textContent = p.desc || '';

    const inp = document.createElement('input');
    inp.type = 'range'; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = p.init;
    inp.setAttribute('aria-label', p.name + ' slider');

    const val = document.createElement('input');
    val.type = 'number'; val.className = 'val'; val.min = p.min; val.max = p.max; val.step = p.step; val.value = p.init;
    val.setAttribute('aria-label', p.name + ' value');

    inp.addEventListener('input', () => { val.value = parseFloat(inp.value); update(); });
    val.addEventListener('input', () => {
      const v = parseFloat(val.value);
      if (!isNaN(v)) {
        const clamped = Math.max(p.min, Math.min(p.max, v));
        val.value = clamped;
        inp.value = clamped;
        update();
      }
    });

    const hintText = p.hint || p.desc || '';
    const showHint = () => { paramHint.textContent = hintText || 'Hover or focus a parameter to see what it controls.'; };
    const clearHint = () => { paramHint.textContent = 'Hover or focus a parameter to see what it controls.'; };
    lbl.addEventListener('mouseenter', showHint);
    lbl.addEventListener('mouseleave', clearHint);
    lbl.addEventListener('focus', showHint);
    lbl.addEventListener('blur', clearHint);
    inp.addEventListener('mouseenter', showHint);
    inp.addEventListener('mouseleave', clearHint);
    inp.addEventListener('focus', showHint);
    inp.addEventListener('blur', clearHint);
    val.addEventListener('mouseenter', showHint);
    val.addEventListener('mouseleave', clearHint);
    val.addEventListener('focus', showHint);
    val.addEventListener('blur', clearHint);

    row.append(lbl, desc, inp, val);
    paramsDiv.appendChild(row);
    sliders[p.name] = { range: inp, number: val, def: p };
  }
  update();
}

function getParams() {
  const p = {};
  for (const [k, obj] of Object.entries(sliders)) {
    let v = parseFloat(obj.range.value);
    if (isNaN(v)) v = obj.def.init;
    const clamped = Math.max(obj.def.min, Math.min(obj.def.max, v));
    if (clamped !== v) {
      obj.range.value = clamped;
      obj.number.value = clamped;
    }
    p[k] = clamped;
  }
  if (distSelect.value === 'uniform' && p['a'] >= p['b']) {
    p['b'] = p['a'] + 0.1;
    const bObj = sliders['b'];
    if (bObj) {
      bObj.range.value = p['b'];
      bObj.number.value = p['b'];
    }
  }
  return p;
}

function safeCdf(d, p, x) {
  const v = d.cdf(x, p);
  if (!isFinite(v) || isNaN(v)) return x < 0 ? 0 : 1;
  return Math.min(1, Math.max(0, v));
}

function expandBracket(d, p, target, lo, hi) {
  let flo = safeCdf(d, p, lo);
  let fhi = safeCdf(d, p, hi);
  let span = hi - lo;
  if (!isFinite(span) || span <= 0) span = 1;
  for (let i = 0; i < 80; i++) {
    if (flo <= target && fhi >= target) return { lo, hi, flo, fhi, ok: true };
    if (flo > target) {
      lo -= span;
      flo = safeCdf(d, p, lo);
    }
    if (fhi < target) {
      hi += span;
      fhi = safeCdf(d, p, hi);
    }
    span *= 2;
  }
  return { lo, hi, flo, fhi, ok: flo <= target && fhi >= target };
}

function invCdf(d, p, target, lo, hi) {
  if (target <= 0) return lo;
  if (target >= 1) return hi;
  const br = expandBracket(d, p, target, lo, hi);
  if (!br.ok) return (br.lo + br.hi) / 2;
  let a = br.lo;
  let b = br.hi;
  for (let i = 0; i < 100; i++) {
    const mid = (a + b) / 2;
    const fm = safeCdf(d, p, mid);
    if (fm < target) a = mid; else b = mid;
  }
  return (a + b) / 2;
}

function computePlotRange(d, p) {
  let [glo, ghi] = d.range(p);
  if (!isFinite(glo)) glo = -1;
  if (!isFinite(ghi)) ghi = 1;
  if (glo === ghi) { glo -= 1; ghi += 1; }
  if (glo > ghi) [glo, ghi] = [ghi, glo];
  const lo = invCdf(d, p, PLOT_QUANTILES.low, glo, ghi);
  const hi = invCdf(d, p, PLOT_QUANTILES.high, glo, ghi);
  if (!isFinite(lo) || !isFinite(hi) || lo === hi) {
    return { baseLo: glo, baseHi: ghi };
  }
  return { baseLo: Math.min(lo, hi), baseHi: Math.max(lo, hi) };
}

function safePdf(d, p, x, lo, hi) {
  let y = d.pdf(x, p);
  if (isFinite(y)) return y;
  const span = hi - lo;
  const eps = span > 0 ? span * 1e-6 : 1e-6;
  let x2 = x;
  if (x === lo) x2 = x + eps;
  else if (x === hi) x2 = x - eps;
  else x2 = x + (x < (lo + hi) / 2 ? eps : -eps);
  y = d.pdf(x2, p);
  return isFinite(y) ? y : 0;
}

function fmt(v) {
  if (v === null || v === undefined) return '—';
  if (v === Infinity) return '∞';
  if (v === -Infinity) return '-∞';
  return Number.isInteger(v) ? v.toString() : v.toFixed(4);
}

function findMedian(d, p, lo, hi) {
  return invCdf(d, p, 0.5, lo, hi);
}


function computeProb(d, p, lo, hi) {
  const a = infAActive ? -Infinity : parseFloat(probA.value);
  const b = infBActive ? Infinity : parseFloat(probB.value);
  let prob = safeCdf(d, p, b) - safeCdf(d, p, a);
  prob = Math.max(0, Math.min(1, prob));
  probResult.textContent = prob.toFixed(6);
  const visA = infAActive ? lo : a;
  const visB = infBActive ? hi : b;
  return { prob, a, b, visA, visB };
}

const PLOT_LAYOUT = {
  margin: { t: 36, b: 40, l: 50, r: 16 },
  height: 380,
  xaxis: { title: { text: 'x', font: { size: 13 } }, gridcolor: '#f0f0f0', zeroline: false, fixedrange: true },
  yaxis: { rangemode: 'tozero', gridcolor: '#f0f0f0', zeroline: false, fixedrange: true },
  hovermode: 'closest',
  showlegend: false,
  plot_bgcolor: '#fff',
  paper_bgcolor: '#fff',
};

function update() {
  const edited = lastEditedBound;
  lastEditedBound = null;
  if (!ensureValidBounds(edited)) return;
  const d = DISTS[distSelect.value];
  const p = getParams();

  const { baseLo, baseHi } = computePlotRange(d, p);

  const { prob, a, b, visA, visB } = computeProb(d, p, baseLo, baseHi);

  let lo = baseLo;
  let hi = baseHi;
  if (!infAActive && isFinite(a)) lo = Math.min(lo, a);
  if (!infBActive && isFinite(b)) hi = Math.max(hi, b);
  const span = hi - lo;
  const pad = span > 0 ? span * 0.05 : 1;
  lo -= pad;
  hi += pad;
  const shadeA = infAActive ? lo : visA;
  const shadeB = infBActive ? hi : visB;

  const N = 500;
  const xs = Array.from({length: N}, (_, i) => lo + (hi-lo)*i/(N-1));
  const pdfY = xs.map(x => safePdf(d, p, x, lo, hi));
  const cdfY = xs.map(x => safeCdf(d, p, x));

  let yMax = 0;
  for (const y of pdfY) if (isFinite(y) && y > yMax) yMax = y;
  yMax = yMax * 1.15 || 1;

  const pdfTraces = [{ x: xs, y: pdfY, type: 'scatter', mode: 'lines', line: { width: 2.5, color: '#e74c3c' }, name: 'PDF',
    hovertemplate: 'x=%{x:.3f}<br>f(x)=%{y:.4f}<extra></extra>' }];

  // Shaded region
  if (prob !== null) {
    const shadeX = [], shadeY = [];
    for (let i = 0; i < N; i++) {
      if (xs[i] >= shadeA && xs[i] <= shadeB) { shadeX.push(xs[i]); shadeY.push(pdfY[i]); }
    }
    if (shadeX.length > 0) {
      pdfTraces.push({
        x: [shadeX[0], ...shadeX, shadeX[shadeX.length-1]],
        y: [0, ...shadeY, 0],
        type: 'scatter', fill: 'toself', fillcolor: 'rgba(108,92,231,0.2)',
        line: { color: 'rgba(108,92,231,0.4)', width: 1 }, name: 'P(a<X<b)',
        hoverinfo: 'skip',
      });
    }
  }

  // Stats
  const meanVal = d.mean(p);
  const modeVal = d.mode(p);
  const medVal = findMedian(d, p, baseLo, baseHi);
  const varVal = d.variance(p);
  const sdVal = (varVal !== null) ? (isFinite(varVal) ? Math.sqrt(varVal) : Infinity) : null;

  // ±σ band + mean/median/mode lines
  const pdfShapes = [];
  if (sdVal !== null && isFinite(sdVal) && meanVal !== null && isFinite(meanVal)) {
    const bandLo = Math.max(lo, meanVal - sdVal);
    const bandHi = Math.min(hi, meanVal + sdVal);
    pdfShapes.push({ type:'rect', x0:bandLo, x1:bandHi, y0:0, y1:1, yref:'paper',
      fillcolor:'rgba(46,204,113,0.1)', line:{ width:0 } });
  }
  if (meanVal !== null && isFinite(meanVal) && meanVal >= lo && meanVal <= hi) {
    pdfShapes.push({ type:'line', x0:meanVal, x1:meanVal, y0:0, y1:1, yref:'paper',
      line:{ color:'#2ecc71', width:1.5, dash:'dash' } });
  }
  if (medVal !== null && isFinite(medVal) && medVal >= lo && medVal <= hi) {
    pdfShapes.push({ type:'line', x0:medVal, x1:medVal, y0:0, y1:1, yref:'paper',
      line:{ color:'#9b59b6', width:1.5, dash:'dash' } });
  }
  if (modeVal !== null && isFinite(modeVal) && modeVal >= lo && modeVal <= hi) {
    pdfShapes.push({ type:'line', x0:modeVal, x1:modeVal, y0:0, y1:1, yref:'paper',
      line:{ color:'#f39c12', width:1.5, dash:'dot' } });
  }

  // Stat bar
  let statHtml = '';
  statHtml += '<span><i class="stat-swatch mean"></i>mean=' + fmt(meanVal) + '</span>';
  statHtml += '<span><i class="stat-swatch median"></i>med=' + fmt(medVal) + '</span>';
  statHtml += '<span><i class="stat-swatch mode"></i>mode=' + (modeVal === null ? 'N/A' : fmt(modeVal)) + '</span>';
  statHtml += '<span><i class="stat-swatch sigma"></i>&sigma;=' + (sdVal === null ? '—' : fmt(sdVal)) + '</span>';
  document.getElementById('stat-bar').innerHTML = statHtml;

  Plotly.react('pdf-plot', pdfTraces,
    { ...PLOT_LAYOUT, title: { text: 'PDF — ' + d.label, font: { size: 15 } }, shapes: pdfShapes,
      xaxis: { ...PLOT_LAYOUT.xaxis, range: [lo, hi] },
      yaxis: { ...PLOT_LAYOUT.yaxis, range: [0, yMax] } },
    { responsive: true, displayModeBar: false });

  // CDF
  const cdfTraces = [{ x: xs, y: cdfY, type: 'scatter', mode: 'lines', line: { width: 2.5, color: '#3498db' },
    hovertemplate: 'x=%{x:.3f}<br>F(x)=%{y:.4f}<extra></extra>' }];
  const cdfShapes = [];
  const cdfAnnotations = [];

  if (prob !== null) {
    const fa = infAActive ? 0 : safeCdf(d, p, shadeA);
    const fb = infBActive ? 1 : safeCdf(d, p, shadeB);
    cdfShapes.push(
      { type:'line', x0:shadeA, x1:shadeA, y0:0, y1:fa, line:{ color:'#6c5ce7', width:1.5, dash:'dash' } },
      { type:'line', x0:shadeB, x1:shadeB, y0:0, y1:fb, line:{ color:'#6c5ce7', width:1.5, dash:'dash' } },
      { type:'line', x0:lo, x1:shadeA, y0:fa, y1:fa, line:{ color:'#6c5ce7', width:1, dash:'dot' } },
      { type:'line', x0:lo, x1:shadeB, y0:fb, y1:fb, line:{ color:'#6c5ce7', width:1, dash:'dot' } },
      { type:'line', x0:shadeB, x1:shadeB, y0:fa, y1:fb, line:{ color:'#6c5ce7', width:2.5 } },
    );
    cdfTraces.push({ x:[shadeA,shadeB], y:[fa,fb], type:'scatter', mode:'markers',
      marker:{ color:'#6c5ce7', size:7 }, showlegend:false, hoverinfo:'skip' });
    cdfAnnotations.push(
      { x:lo, y:fa, xanchor:'left', yanchor:'bottom', text:'F(a)='+fa.toFixed(3), showarrow:false, font:{size:10, color:'#6c5ce7'} },
      { x:lo, y:fb, xanchor:'left', yanchor:'bottom', text:'F(b)='+fb.toFixed(3), showarrow:false, font:{size:10, color:'#6c5ce7'} },
      { x:shadeB, y:(fa+fb)/2, xanchor:'left', text:' P='+prob.toFixed(4), showarrow:false, font:{size:11, color:'#6c5ce7'} },
    );
  }

  Plotly.react('cdf-plot', cdfTraces,
    { ...PLOT_LAYOUT, title: { text: 'CDF — ' + d.label, font: { size: 15 } },
      xaxis: { ...PLOT_LAYOUT.xaxis, range: [lo, hi] },
      yaxis: { ...PLOT_LAYOUT.yaxis, range: [-0.02, 1.05] }, shapes: cdfShapes, annotations: cdfAnnotations },
    { responsive: true, displayModeBar: false });

  setupCrosshair();
}

let crosshairSetup = false;
function setupCrosshair() {
  if (crosshairSetup) return;
  crosshairSetup = true;
  const pdfEl = document.getElementById('pdf-plot');
  const cdfEl = document.getElementById('cdf-plot');

  pdfEl.on('plotly_hover', (data) => {
    const x = data.points[0].x;
    const cur = cdfEl.layout.shapes || [];
    const kept = cur.filter(s => !s._crosshair);
    kept.push({ type:'line', x0:x, x1:x, y0:0, y1:1, line:{color:'#bbb',width:1,dash:'dot'}, _crosshair:true });
    Plotly.relayout('cdf-plot', { shapes: kept });
  });
  pdfEl.on('plotly_unhover', () => {
    const cur = cdfEl.layout.shapes || [];
    Plotly.relayout('cdf-plot', { shapes: cur.filter(s => !s._crosshair) });
  });

  cdfEl.on('plotly_hover', (data) => {
    const x = data.points[0].x;
    const cur = pdfEl.layout.shapes || [];
    const kept = cur.filter(s => !s._crosshair);
    kept.push({ type:'line', x0:x, x1:x, y0:0, y1:1, yref:'paper', line:{color:'#bbb',width:1,dash:'dot'}, _crosshair:true });
    Plotly.relayout('pdf-plot', { shapes: kept });
  });
  cdfEl.on('plotly_unhover', () => {
    const cur = pdfEl.layout.shapes || [];
    Plotly.relayout('pdf-plot', { shapes: cur.filter(s => !s._crosshair) });
  });
}

document.getElementById('explainer-btn').addEventListener('click', (e) => {
  e.preventDefault();
  const el = document.getElementById('explainer');
  const visible = el.style.display !== 'none';
  el.style.display = visible ? 'none' : 'block';
  e.target.textContent = visible ? 'What am I looking at?' : 'Hide explanation';
});

probA.addEventListener('input', () => { lastEditedBound = 'a'; update(); });
probB.addEventListener('input', () => { lastEditedBound = 'b'; update(); });
distSelect.addEventListener('change', buildParams);
buildParams();
setupCrosshair();
</script>
</body>
</html>
